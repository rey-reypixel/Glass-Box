<!DOCTYPE html>
<html>
<head>
    <title>C Lexer & Parser Visualizer</title>

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            background-color: #f4f6f8;
        }

        h1 {
            text-align: center;
        }

        textarea {
            width: 100%;
            height: 120px;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
        }

        button {
            padding: 8px 16px;
            margin-top: 10px;
            cursor: pointer;
        }

        .section {
            margin-top: 30px;
        }

        #codeDisplay {
            background: #1e1e1e;
            color: white;
            padding: 15px;
            font-family: monospace;
            white-space: pre;
            border-radius: 6px;
            min-height: 120px;
            margin-top: 10px;
        }

        #executionBox {
            background: black;
            color: #00ff00;
            padding: 20px;
            font-family: monospace;
            min-height: 140px;
            border-radius: 8px;
        }

        #symbolTableBox {
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
        }

        table {
            border-collapse: collapse;
            width: 50%;
        }

        table th, table td {
            border: 1px solid #999;
            padding: 6px 12px;
            text-align: center;
        }

        table th {
            background-color: #e0e0e0;
        }

        #dfaSvg {
            background: #111;
            border-radius: 8px;
        }

    </style>
</head>

<body>

<h1>C Lexer & Parser Visualizer</h1>

<div class="section">
    <h3>Input C Code</h3>
    <textarea id="codeInput">
int x = 10;
float y = 20.5;
    </textarea>
    <br>
    <button onclick="analyzeCode()">Analyze</button>

    <h4>Code Execution View</h4>
    <div id="codeDisplay"></div>
</div>

<div class="section">
    <h3>Live Execution</h3>

    <div id="executionBox">
        Press Analyze to start...
    </div>

    <br>
    <button onclick="playSteps()">▶ Play</button>
    <button onclick="pauseSteps()">⏸ Pause</button>

    <br><br>
    Speed:
    <input type="range" min="100" max="1000" value="500" id="speedSlider">
</div>

<div class="section">
    <h3>Symbol Table (Live)</h3>
    <div id="symbolTableBox"></div>
</div>

<div class="section">
    <h3>DFA State Visualization</h3>
    
    <div style="margin-bottom: 15px;">
        <button onclick="switchDFAView('static')">Static DFA</button>
    </div>
    
    <div id="staticDFA" style="display: block;">
        <svg id="dfaSvg" width="800" height="400"></svg>
    </div>
</div>

<div class="section">
    <h3>Syntax Analysis</h3>
    
    <div style="margin-bottom: 20px;">
        <button onclick="switchView('ast')">AST View</button>
        <button onclick="switchView('parse')">Parse Steps</button>
        <button onclick="switchView('both')">Both Views</button>
        <button onclick="switchView('parser')">Parser Info</button>
        <button onclick="switchView('animated')">Animated View</button>
    </div>
    
    <div id="animatedView" style="display: none;">
        <h4>Step-by-Step Parsing Animation</h4>
        
        <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px;">
            <div style="display: flex; gap: 10px; align-items: center;">
                <button onclick="startAnimation()" id="playBtn" style="background: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 4px;">▶ Play</button>
                <button onclick="pauseAnimation()" id="pauseBtn" style="background: #ffc107; color: black; padding: 8px 16px; border: none; border-radius: 4px; display: none;">⏸ Pause</button>
                <button onclick="resetAnimation()" style="background: #dc3545; color: white; padding: 8px 16px; border: none; border-radius: 4px;">⏹ Reset</button>
                
                <div style="margin-left: 20px;">
                    <label>Speed:</label>
                    <select id="speedControl" onchange="changeSpeed()" style="padding: 4px;">
                        <option value="2000">Very Slow (2s)</option>
                        <option value="1500">Slow (1.5s)</option>
                        <option value="1000" selected>Normal (1s)</option>
                        <option value="500">Fast (0.5s)</option>
                        <option value="200">Very Fast (0.2s)</option>
                    </select>
                </div>
                
                <div style="margin-left: 20px;">
                    <span id="stepCounter">Step 0 / 0</span>
                </div>
            </div>
        </div>
        
        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
            <div style="flex: 1; background: #e9ecef; padding: 15px; border-radius: 8px;">
                <h5>Current Token</h5>
                <div id="currentTokenDisplay" style="font-family: monospace; font-size: 14px; padding: 10px; background: white; border-radius: 4px; min-height: 40px;">
                    Waiting to start...
                </div>
            </div>
            
            <div style="flex: 1; background: #e9ecef; padding: 15px; border-radius: 8px;">
                <h5>Current Routine</h5>
                <div id="currentRoutineDisplay" style="font-weight: bold; color: #007bff; font-size: 14px; padding: 10px; background: white; border-radius: 4px; min-height: 40px;">
                    Waiting to start...
                </div>
            </div>
        </div>
        
        <div style="display: flex; gap: 20px; margin-bottom: 20px;">
            <div style="flex: 1; background: #e9ecef; padding: 15px; border-radius: 8px;">
                <h5>Parse Stack</h5>
                <div id="parseStackDisplay" style="font-family: monospace; font-size: 12px; max-height: 150px; overflow-y: auto; background: white; padding: 10px; border-radius: 4px;">
                    Empty
                </div>
            </div>
            
            <div style="flex: 1; background: #e9ecef; padding: 15px; border-radius: 8px;">
                <h5>Action</h5>
                <div id="actionDisplay" style="font-size: 14px; padding: 10px; background: white; border-radius: 4px; min-height: 40px;">
                    Waiting to start...
                </div>
            </div>
        </div>
        
        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
            <h5>Live AST Building</h5>
            <svg id="animatedAstSvg" width="800" height="300" style="background: white; border: 1px solid #ccc; border-radius: 8px;"></svg>
        </div>
    </div>
    
    <div id="parserView" style="display: none;">
        <h4>Parser Configuration</h4>
        <div style="display: flex; gap: 20px;">
            <div style="flex: 1; background: #f8f9fa; padding: 15px; border-radius: 8px;">
                <h5>Parser Type</h5>
                <p id="parserType">Loading...</p>
                <h5>Grammar Class</h5>
                <p id="grammarClass">Loading...</p>
            </div>
            <div style="flex: 1; background: #e9ecef; padding: 15px; border-radius: 8px;">
                <h5>Current Routine</h5>
                <p id="currentRoutine" style="font-weight: bold; color: #007bff;">Waiting...</p>
                <h5>Parse Stack</h5>
                <div id="parseStack" style="font-family: monospace; font-size: 12px; max-height: 150px; overflow-y: auto; background: white; padding: 10px; border-radius: 4px;">
                    Empty
                </div>
            </div>
        </div>
        <h4>Grammar Rules</h4>
        <div id="grammarRules" style="background: #f8f9fa; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 12px;">
            Loading grammar rules...
        </div>
    </div>
    
    <div id="astView" style="display: block;">
        <h4>Abstract Syntax Tree</h4>
        <svg id="astSvg" width="800" height="400" style="background: white; border: 1px solid #ccc; border-radius: 8px;"></svg>
    </div>
    
    <div id="parseView" style="display: none;">
        <h4>Parse Steps</h4>
        <div id="parseBox" style="background: #f0f0f0; padding: 15px; font-family: monospace; min-height: 200px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
            Press Analyze to see parse steps...
        </div>
    </div>
</div>

<script>

// ===============================
// GLOBALS
// ===============================

let stepsData = [];
let parseStepsData = [];
let astData = null;
let currentStep = 0;
let interval = null;


// ===============================
// ANALYZE
// ===============================

function analyzeCode() {

    pauseSteps();

    const code = document.getElementById("codeInput").value;
    console.log("Code to analyze:", code);

    document.getElementById("codeDisplay").textContent = code;
    
    // Show immediate feedback
    document.getElementById("executionBox").innerHTML = 
        "<span style='color:blue'>Analyzing... Please wait...</span>";

    fetch("/analyze", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ code: code })
    })
    .then(res => {
        console.log("Response status:", res.status);
        if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
        }
        return res.json();
    })
    .then(data => {
        console.log("Response data:", data);
        if (data.success) {
            stepsData = data.steps;
            parseStepsData = data.parse_steps || [];
            astData = data.ast;
            currentStep = 0;

            document.getElementById("executionBox").innerHTML =
                "<span style='color:green'>Analysis Complete! Ready to visualize...</span>";

            document.getElementById("symbolTableBox").innerHTML = "";

            drawDFA();
            drawAST();
            displayParseSteps();
        } else {
            // Handle errors
            let errorMsg = data.error;
            if (data.error_type === "syntax") {
                errorMsg = `Syntax Error: ${data.error} (line ${data.line})`;
                if (data.expected && data.found) {
                    errorMsg += `<br>Expected: ${data.expected}, Found: ${data.found}`;
                }
            } else if (data.error_type === "lexical") {
                errorMsg = `Lexical Error: ${data.error} (line ${data.line}, column ${data.column})`;
            }
            
            document.getElementById("executionBox").innerHTML = 
                `<span style='color:red'>${errorMsg}</span>`;
        }
    })
    .catch(error => {
        console.error("Fetch error:", error);
        document.getElementById("executionBox").innerHTML = 
            `<span style='color:red'>Network Error: ${error.message}</span>`;
    });
}


// ===============================
// PLAYBACK
// ===============================

function playSteps() {

    if (interval) return;

    let speed = document.getElementById("speedSlider").value;

    interval = setInterval(() => {

        if (currentStep >= stepsData.length) {
            clearInterval(interval);
            interval = null;
            return;
        }

        showStep(stepsData[currentStep]);
        currentStep++;

    }, speed);
}

function pauseSteps() {
    clearInterval(interval);
    interval = null;
}


// ===============================
// STEP DISPLAY
// ===============================

function showStep(step) {

    highlightCharacter(step);
    updateSymbolTable(step);
    highlightState(step.current_state);

    let color = "#00ff00";

    if (step.action === "BUILDING_IDENTIFIER") color = "#00ffff";
    if (step.action === "BUILDING_NUMBER") color = "#66ff66";
    if (step.action === "DECIMAL_POINT") color = "#ff66ff";
    if (step.action === "TOKEN_GENERATED") color = "#ffcc00";
    if (step.action === "WHITESPACE_SKIP") color = "#888888";
    if (step.action === "ERROR_UNKNOWN_CHAR") color = "#ff0000";

    document.getElementById("executionBox").innerHTML = `
        <div style="color:${color};">
        <b>Character:</b> ${step.char || "-"}<br>
        <b>Action:</b> ${step.action}<br>
        <b>State:</b> ${step.current_state}<br>
        <b>Lexeme:</b> ${step.current_lexeme}<br>
        <b>Token:</b> ${step.token_generated || "-"}
        </div>
    `;
}


// ===============================
// CHARACTER HIGHLIGHT
// ===============================

function highlightCharacter(step) {

    const code = document.getElementById("codeInput").value;

    if (!step.char) {
        document.getElementById("codeDisplay").textContent = code;
        return;
    }

    let index = findCharIndex(code, step.line, step.column);

    let before = code.slice(0, index);
    let current = code[index] || "";
    let after = code.slice(index + 1);

    document.getElementById("codeDisplay").innerHTML =
        before +
        `<span style="background: yellow; color: black;">${current}</span>` +
        after;
}

function findCharIndex(code, line, column) {

    let lines = code.split("\n");
    let index = 0;

    for (let i = 0; i < line - 1; i++)
        index += lines[i].length + 1;

    return index + (column - 1);
}


// ===============================
// SYMBOL TABLE
// ===============================

function updateSymbolTable(step) {

    let tableHTML =
        "<table><tr><th>Identifier</th><th>Type</th><th>Size</th><th>Line</th></tr>";

    for (let key in step.symbol_table_snapshot) {
        let entry = step.symbol_table_snapshot[key];

        tableHTML += `<tr>
            <td>${key}</td>
            <td>${entry.type || "-"}</td>
            <td>${entry.size || "-"}</td>
            <td>${entry.declared_line || "-"}</td>
        </tr>`;
    }

    tableHTML += "</table>";
    document.getElementById("symbolTableBox").innerHTML = tableHTML;
}


// ===============================
// D3 DFA VISUALIZATION
// ===============================

let svg = d3.select("#dfaSvg");

const nodes = [
    { id: "START", x: 100, y: 200 },
    { id: "KEYWORD", x: 300, y: 50 },
    { id: "IDENTIFIER", x: 300, y: 150 },
    { id: "NUMBER", x: 300, y: 300 },
    { id: "FLOAT", x: 500, y: 300 },
    { id: "STRING", x: 500, y: 200 },
    { id: "OPERATOR", x: 500, y: 100 }
];

const links = [
    { source: "START", target: "KEYWORD" },
    { source: "START", target: "IDENTIFIER" },
    { source: "START", target: "NUMBER" },
    { source: "START", target: "STRING" },
    { source: "START", target: "OPERATOR" },
    { source: "IDENTIFIER", target: "IDENTIFIER" },
    { source: "NUMBER", target: "NUMBER" },
    { source: "NUMBER", target: "FLOAT" },
    { source: "STRING", target: "STRING" }
];

function drawDFA() {

    svg.selectAll("*").remove();

    svg.append("defs")
        .append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 30)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#888");

    links.forEach(link => {

        let source = nodes.find(n => n.id === link.source);
        let target = nodes.find(n => n.id === link.target);

        svg.append("line")
            .attr("x1", source.x)
            .attr("y1", source.y)
            .attr("x2", target.x)
            .attr("y2", target.y)
            .attr("stroke", "#888")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrow)");
    });

    svg.selectAll("circle")
        .data(nodes)
        .enter()
        .append("circle")
        .attr("id", d => "node-" + d.id)
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("r", 40)
        .attr("fill", "#444");

    svg.selectAll("text")
        .data(nodes)
        .enter()
        .append("text")
        .attr("x", d => d.x)
        .attr("y", d => d.y + 5)
        .attr("text-anchor", "middle")
        .attr("fill", "white")
        .text(d => d.id);
}

function highlightState(currentState) {

    nodes.forEach(node => {
        d3.select("#node-" + node.id)
            .transition()
            .duration(300)
            .attr("fill", node.id === currentState ? "#00ff00" : "#444");
    });
}

drawDFA();


// ===============================
// SYNTAX ANALYSIS FUNCTIONS
// ===============================

function switchView(view) {
    const astView = document.getElementById("astView");
    const parseView = document.getElementById("parseView");
    const parserView = document.getElementById("parserView");
    const animatedView = document.getElementById("animatedView");
    
    // Hide all views first
    astView.style.display = "none";
    parseView.style.display = "none";
    parserView.style.display = "none";
    animatedView.style.display = "none";
    
    if (view === "ast") {
        astView.style.display = "block";
    } else if (view === "parse") {
        parseView.style.display = "block";
    } else if (view === "both") {
        astView.style.display = "block";
        parseView.style.display = "block";
    } else if (view === "parser") {
        parserView.style.display = "block";
        updateParserInfo();
    } else if (view === "animated") {
        animatedView.style.display = "block";
        if (!parseStepsData || parseStepsData.length === 0) {
            document.getElementById("currentTokenDisplay").innerHTML = 
                '<span style="color: #6c757d;">Please analyze code first to see animation</span>';
        } else {
            setupAnimation();
        }
    }
}

function drawAST() {
    if (!astData) return;
    
    const svg = d3.select("#astSvg");
    svg.selectAll("*").remove();
    
    const width = 800;
    const height = 400;
    const margin = {top: 20, right: 20, bottom: 20, left: 20};
    
    const treeLayout = d3.tree()
        .size([width - margin.left - margin.right, height - margin.top - margin.bottom]);
    
    const root = d3.hierarchy(astData);
    const treeData = treeLayout(root);
    
    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
    
    // Draw links
    g.selectAll(".link")
        .data(treeData.links())
        .enter()
        .append("line")
        .attr("class", "link")
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y)
        .attr("stroke", "#999")
        .attr("stroke-width", 2);
    
    // Draw nodes
    const nodes = g.selectAll(".node")
        .data(treeData.descendants())
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x},${d.y})`);
    
    nodes.append("circle")
        .attr("r", 8)
        .attr("fill", d => {
            switch(d.data.type) {
                case "Program": return "#ff6b6b";
                case "Declaration": return "#4ecdc4";
                case "Assignment": return "#e74c3c";  // Red for assignment operator
                case "BinaryOp": return "#3498db";   // Blue for arithmetic operators
                case "ExpressionStmt": return "#f39c12"; // Orange for expression statements
                case "Number": return "#f39c12";      // Orange for numbers
                case "String": return "#fdcb6e";
                case "Identifier": return "#95a5a6";  // Gray for identifiers
                case "FunctionCall": return "#9b59b6"; // Purple for function calls
                default: return "#74b9ff";
            }
        })
        .attr("stroke", "#333")
        .attr("stroke-width", 2);
    
    nodes.append("text")
        .attr("dy", -15)
        .attr("text-anchor", "middle")
        .style("font-size", "12px")
        .style("font-weight", "bold")
        .text(d => {
            let label = d.data.type;
            if (d.data.operator) {
                label = d.data.operator;  // Show operator as the main label
            } else if (d.data.value) {
                label += `: ${d.data.value}`;
            } else if (d.data.name) {
                label += `: ${d.data.name}`;
            } else if (d.data.var_type) {
                label += ` (${d.data.var_type})`;
            } else if (d.data.identifier) {
                label += ` ${d.data.identifier}`;
            } else if (d.data.function_name) {
                label += `: ${d.data.function_name}()`;
            }
            return label;
        });
}

function displayParseSteps() {
    const parseBox = document.getElementById("parseBox");
    if (!parseStepsData || parseStepsData.length === 0) {
        parseBox.innerHTML = "No parse steps available.";
        return;
    }
    
    let html = "";
    let currentStack = [];
    
    parseStepsData.forEach((step, index) => {
        const color = step.action === "CREATE_NODE" ? "#2ecc71" : 
                     step.action === "CONSUME" ? "#3498db" : 
                     step.action === "ROUTINE" ? "#9b59b6" : 
                     step.action === "OPERATOR" ? "#f39c12" :
                     step.action === "START" ? "#e74c3c" : 
                     step.action === "COMPLETE" ? "#28a745" : "#95a5a6";
        
        html += `
            <div style="margin-bottom: 10px; padding: 8px; background: white; border-left: 4px solid ${color}; border-radius: 4px;">
                <strong>Step ${index + 1}:</strong> ${step.action}<br>
                ${step.message ? `<em>${step.message}</em><br>` : ""}
                <small>Token: ${step.current_token || "None"}</small>
                ${step.node_created ? `<br><small>Node: ${step.node_created}</small>` : ""}
                ${step.routine ? `<br><small style="color: #9b59b6;">Routine: ${step.routine}</small>` : ""}
            </div>
        `;
        
        // Update current routine and stack
        if (step.routine) {
            updateCurrentRoutine(step.routine);
            
            // Add to stack if it's a routine call
            if (step.action === "ROUTINE") {
                currentStack.push(step.routine);
                updateParseStack(currentStack);
            }
            
            // Remove from stack when completing
            if (step.action === "COMPLETE" || step.action === "CREATE_NODE") {
                if (currentStack.length > 0) {
                    currentStack.pop();
                    updateParseStack(currentStack);
                }
            }
        }
    });
    
    parseBox.innerHTML = html;
}

function updateParserInfo() {
    console.log("Updating parser info...");
    
    // Update parser type information
    document.getElementById("parserType").innerHTML = 
        `<strong>Recursive Descent Parser</strong><br>
        <small>LL(1) Grammar • Top-down • Predictive</small>`;
    
    document.getElementById("grammarClass").innerHTML = 
        `<strong>Context-Free Grammar (CFG)</strong><br>
        <small>Unambiguous • No Left Recursion • FIRST/FOLLOW Sets</small>`;
    
    // Display grammar rules
    const grammarRules = document.getElementById("grammarRules");
    grammarRules.innerHTML = `
        <div style="margin-bottom: 10px;"><strong>Program → Statement*</strong></div>
        <div style="margin-bottom: 10px;"><strong>Statement → Declaration | Assignment | FunctionCall | ExpressionStmt</strong></div>
        <div style="margin-bottom: 10px;"><strong>Declaration → Type Identifier [ = Expression ] ;</strong></div>
        <div style="margin-bottom: 10px;"><strong>Assignment → Identifier = Expression ;</strong></div>
        <div style="margin-bottom: 10px;"><strong>FunctionCall → Identifier ( ArgList ) ;</strong></div>
        <div style="margin-bottom: 10px;"><strong>ExpressionStmt → Expression ;</strong></div>
        <div style="margin-bottom: 10px;"><strong>Expression → Expression + Term | Expression - Term | Term</strong></div>
        <div style="margin-bottom: 10px;"><strong>Term → Term * Factor | Term / Factor | Factor</strong></div>
        <div style="margin-bottom: 10px;"><strong>Factor → Number | String | Identifier | ( Expression )</strong></div>
        <div style="margin-bottom: 10px;"><strong>Type → int | float | char | double</strong></div>
        <div style="margin-bottom: 10px;"><strong>ArgList → Expression [ , ArgList ]</strong></div>
        
        <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 4px;">
            <strong>Operator Precedence (Highest → Lowest):</strong><br>
            <div style="margin-left: 20px;">
                () • * / • + - • =<br>
                <small>Parentheses bind tightest, then multiplication/division, then addition/subtraction, then assignment</small>
            </div>
        </div>
        
        <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 4px;">
            <strong>Parser Routines (Functions):</strong><br>
            <div style="margin-left: 20px; font-family: monospace; font-size: 11px;">
                • parse_program() - Main entry point<br>
                • parse_declaration_or_assignment() - Handles declarations<br>
                • parse_identifier_statement() - Handles identifiers<br>
                • parse_expression() - Entry for expressions<br>
                • parse_additive_expression() - Handles + and -<br>
                • parse_multiplicative_expression() - Handles * and /<br>
                • parse_primary_expression() - Handles basic tokens<br>
                • parse_function_call() - Handles function calls
            </div>
        </div>
    `;
    
    // Start dynamic routine visualization
    updateCurrentRoutine("Waiting for input...");
    updateParseStack([]);
}

function updateCurrentRoutine(routine) {
    const routineElement = document.getElementById("currentRoutine");
    if (routineElement) {
        routineElement.innerHTML = routine;
        routineElement.style.color = "#007bff";
        
        // Flash effect
        routineElement.style.transition = "all 0.3s ease";
        setTimeout(() => {
            routineElement.style.color = "#28a745";
        }, 100);
    }
}

function updateParseStack(stack) {
    const stackElement = document.getElementById("parseStack");
    if (stackElement) {
        if (stack.length === 0) {
            stackElement.innerHTML = "<span style='color: #6c757d;'>Empty</span>";
        } else {
            let html = "";
            stack.forEach((item, index) => {
                const depth = index * 2;
                const indent = "&nbsp;".repeat(depth);
                const color = item.includes("parse_") ? "#007bff" : 
                           item.includes("Expression") ? "#28a745" : 
                           item.includes("BinaryOp") ? "#ffc107" : "#6c757d";
                html += `<div style="color: ${color};">${indent}• ${item}</div>`;
            });
            stackElement.innerHTML = html;
        }
        
        // Auto-scroll to bottom
        stackElement.scrollTop = stackElement.scrollHeight;
    }
}

// ===============================
// ANIMATION FUNCTIONS
// ===============================

let animationInterval = null;
let currentAnimationStep = 0;
let animationSpeed = 1000;
let animationStack = [];

function setupAnimation() {
    currentAnimationStep = 0;
    animationStack = [];
    updateStepCounter();
    resetAnimationDisplays();
    
    if (parseStepsData && parseStepsData.length > 0) {
        document.getElementById("stepCounter").textContent = `Step 0 / ${parseStepsData.length}`;
    }
}

function startAnimation() {
    if (!parseStepsData || parseStepsData.length === 0) {
        alert("Please analyze code first to see animation");
        return;
    }
    
    document.getElementById("playBtn").style.display = "none";
    document.getElementById("pauseBtn").style.display = "inline-block";
    
    animationInterval = setInterval(() => {
        if (currentAnimationStep >= parseStepsData.length) {
            pauseAnimation();
            return;
        }
        
        executeAnimationStep(parseStepsData[currentAnimationStep]);
        currentAnimationStep++;
        updateStepCounter();
        
        if (currentAnimationStep >= parseStepsData.length) {
            pauseAnimation();
            document.getElementById("actionDisplay").innerHTML = 
                '<span style="color: #28a745;">✓ Parsing Complete!</span>';
        }
    }, animationSpeed);
}

function pauseAnimation() {
    if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
    }
    
    document.getElementById("playBtn").style.display = "inline-block";
    document.getElementById("pauseBtn").style.display = "none";
}

function resetAnimation() {
    pauseAnimation();
    currentAnimationStep = 0;
    animationStack = [];
    setupAnimation();
    updateStepCounter();
}

function changeSpeed() {
    animationSpeed = parseInt(document.getElementById("speedControl").value);
    if (animationInterval) {
        pauseAnimation();
        startAnimation();
    }
}

function executeAnimationStep(step) {
    // Update current token
    const tokenDisplay = document.getElementById("currentTokenDisplay");
    if (step.current_token) {
        tokenDisplay.innerHTML = `<span style="color: #007bff; font-weight: bold;">${step.current_token}</span>`;
    } else {
        tokenDisplay.innerHTML = '<span style="color: #6c757d;">No current token</span>';
    }
    
    // Update current routine
    const routineDisplay = document.getElementById("currentRoutineDisplay");
    if (step.routine) {
        routineDisplay.innerHTML = `<span style="color: #007bff; font-weight: bold;">${step.routine}</span>`;
        routineDisplay.style.transition = "all 0.3s ease";
        setTimeout(() => {
            routineDisplay.style.color = "#28a745";
        }, 100);
    }
    
    // Update action
    const actionDisplay = document.getElementById("actionDisplay");
    const color = step.action === "CREATE_NODE" ? "#28a745" : 
                 step.action === "CONSUME" ? "#3498db" : 
                 step.action === "ROUTINE" ? "#9b59b6" : 
                 step.action === "OPERATOR" ? "#f39c12" :
                 step.action === "START" ? "#e74c3c" : 
                 step.action === "COMPLETE" ? "#28a745" : "#95a5a6";
    
    actionDisplay.innerHTML = `<span style="color: ${color}; font-weight: bold;">${step.action}</span>`;
    if (step.message) {
        actionDisplay.innerHTML += `<br><small style="color: #6c757d;">${step.message}</small>`;
    }
    
    // Update parse stack
    if (step.routine) {
        if (step.action === "ROUTINE") {
            animationStack.push(step.routine);
        } else if (step.action === "COMPLETE" || step.action === "CREATE_NODE") {
            if (animationStack.length > 0) {
                animationStack.pop();
            }
        }
        updateAnimatedParseStack(animationStack);
    }
    
    // Update AST gradually when nodes are created
    if (step.action === "CREATE_NODE" && step.token_generated) {
        updatePartialAST();
    }
    
    // Show final AST when parsing is complete
    if (astData && currentAnimationStep >= parseStepsData.length - 1) {
        setTimeout(() => {
            drawAnimatedAST();
        }, 500);
    }
}

function updateAnimatedParseStack(stack) {
    const stackDisplay = document.getElementById("parseStackDisplay");
    if (stack.length === 0) {
        stackDisplay.innerHTML = "<span style='color: #6c757d;'>Empty</span>";
    } else {
        let html = "";
        stack.forEach((item, index) => {
            const depth = index * 2;
            const indent = "&nbsp;".repeat(depth);
            const color = item.includes("parse_") ? "#007bff" : 
                       item.includes("Expression") ? "#28a745" : 
                       item.includes("BinaryOp") ? "#ffc107" : "#6c757d";
            html += `<div style="color: ${color};">${indent}• ${item}</div>`;
        });
        stackDisplay.innerHTML = html;
    }
    
    stackDisplay.scrollTop = stackDisplay.scrollHeight;
}

function updatePartialAST() {
    // Build a partial AST from the steps processed so far
    const partialSteps = parseStepsData.slice(0, currentAnimationStep + 1);
    const partialNodes = [];
    
    // Extract node creation information from steps
    partialSteps.forEach(step => {
        if (step.action === "CREATE_NODE" && step.token_generated) {
            // Parse the node string to extract basic info
            const nodeStr = step.token_generated;
            if (nodeStr.includes("Number")) {
                partialNodes.push({
                    type: "Number",
                    value: nodeStr.match(/\((.*?)\)/)?.[1] || "0"
                });
            } else if (nodeStr.includes("Identifier")) {
                partialNodes.push({
                    type: "Identifier", 
                    name: nodeStr.match(/\((.*?)\)/)?.[1] || "x"
                });
            } else if (nodeStr.includes("Assignment")) {
                partialNodes.push({
                    type: "Assignment",
                    operator: "="
                });
            } else if (nodeStr.includes("BinaryOp")) {
                partialNodes.push({
                    type: "BinaryOp",
                    operator: nodeStr.match(/\+(.*?)\)/)?.[1] || "+"
                });
            }
        }
    });
    
    // Draw partial AST if we have nodes
    if (partialNodes.length > 0) {
        drawPartialAST(partialNodes);
    }
}

function drawPartialAST(nodes) {
    const svg = d3.select("#animatedAstSvg");
    svg.selectAll("*").remove();
    
    const width = 800;
    const height = 300;
    const margin = {top: 20, right: 20, bottom: 20, left: 20};
    
    // Simple layout for partial nodes
    const nodeWidth = 100;
    const nodeHeight = 40;
    const horizontalSpacing = 20;
    const verticalSpacing = 60;
    
    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
    
    // Draw nodes in a simple layout
    nodes.forEach((node, index) => {
        const x = 50 + (index % 7) * nodeWidth;
        const y = 50 + Math.floor(index / 7) * nodeHeight + verticalSpacing;
        
        // Draw node circle
        g.append("circle")
            .attr("cx", x + nodeWidth/2)
            .attr("cy", y + nodeHeight/2)
            .attr("r", 15)
            .attr("fill", () => {
                switch(node.type) {
                    case "Number": return "#f39c12";
                    case "Identifier": return "#95a5a6";
                    case "Assignment": return "#e74c3c";
                    case "BinaryOp": return "#3498db";
                    default: return "#74b9ff";
                }
            })
            .attr("stroke", "#333")
            .attr("stroke-width", 2);
        
        // Draw node label
        g.append("text")
            .attr("x", x + nodeWidth/2)
            .attr("y", y + nodeHeight/2 - 5)
            .attr("text-anchor", "middle")
            .style("font-size", "12px")
            .style("font-weight", "bold")
            .text(() => {
                if (node.operator) return node.operator;
                if (node.value) return `${node.type}: ${node.value}`;
                if (node.name) return `${node.type}: ${node.name}`;
                return node.type;
            });
    });
    
    // Add "Building..." indicator
    g.append("text")
        .attr("x", width/2)
        .attr("y", height - 10)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .style("font-style", "italic")
        .style("fill", "#6c757d")
        .text("Building AST... (Step " + (currentAnimationStep + 1) + ")");
}

function updateStepCounter() {
    const total = parseStepsData ? parseStepsData.length : 0;
    document.getElementById("stepCounter").textContent = `Step ${currentAnimationStep} / ${total}`;
}

function resetAnimationDisplays() {
    document.getElementById("currentTokenDisplay").innerHTML = "Waiting to start...";
    document.getElementById("currentRoutineDisplay").innerHTML = "Waiting to start...";
    document.getElementById("actionDisplay").innerHTML = "Waiting to start...";
    updateAnimatedParseStack([]);
    
    const svg = d3.select("#animatedAstSvg");
    svg.selectAll("*").remove();
}

function drawAnimatedAST() {
    if (!astData) return;
    
    const svg = d3.select("#animatedAstSvg");
    svg.selectAll("*").remove();
    
    const width = 800;
    const height = 300;
    const margin = {top: 20, right: 20, bottom: 20, left: 20};
    
    const treeLayout = d3.tree()
        .size([width - margin.left - margin.right, height - margin.top - margin.bottom]);
    
    const root = d3.hierarchy(astData);
    const treeData = treeLayout(root);
    
    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
    
    // Draw links
    g.selectAll(".link")
        .data(treeData.links())
        .enter()
        .append("line")
        .attr("class", "link")
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y)
        .attr("stroke", "#999")
        .attr("stroke-width", 2);
    
    // Draw nodes
    const nodes = g.selectAll(".node")
        .data(treeData.descendants())
        .enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x},${d.y})`);
    
    nodes.append("circle")
        .attr("r", 6)
        .attr("fill", d => {
            switch(d.data.type) {
                case "Program": return "#ff6b6b";
                case "Declaration": return "#4ecdc4";
                case "Assignment": return "#e74c3c";
                case "BinaryOp": return "#3498db";
                case "Number": return "#f39c12";
                case "String": return "#fdcb6e";
                case "Identifier": return "#95a5a6";
                case "FunctionCall": return "#9b59b6";
                default: return "#74b9ff";
            }
        })
        .attr("stroke", "#333")
        .attr("stroke-width", 2);
    
    nodes.append("text")
        .attr("dy", -12)
        .attr("text-anchor", "middle")
        .style("font-size", "10px")
        .style("font-weight", "bold")
        .text(d => {
            let label = d.data.type;
            if (d.data.operator) {
                label = d.data.operator;
            } else if (d.data.value) {
                label += `: ${d.data.value}`;
            } else if (d.data.name) {
                label += `: ${d.data.name}`;
            }
            return label;
        });
}

// ===============================
// DFA VISUALIZATION FUNCTIONS
// ===============================

let dfaStates = {
    'START': { x: 100, y: 200, color: '#28a745' },
    'IDENTIFIER': { x: 200, y: 100, color: '#17a2b8' },
    'NUMBER': { x: 300, y: 100, color: '#ffc107' },
    'OPERATOR': { x: 400, y: 100, color: '#dc3545' },
    'STRING': { x: 500, y: 100, color: '#6f42c1' },
    'DELIMITER': { x: 600, y: 100, color: '#e83e8c' },
    'KEYWORD': { x: 700, y: 100, color: '#6610f2' },
    'COMPLETE': { x: 400, y: 300, color: '#28a745' }
};

let dfaTransitions = [
    { from: 'START', to: 'IDENTIFIER', label: 'letter', char: '[a-zA-Z]' },
    { from: 'START', to: 'NUMBER', label: 'digit', char: '[0-9]' },
    { from: 'START', to: 'OPERATOR', label: 'op', char: '[+\\-*/=]' },
    { from: 'START', to: 'STRING', label: '"', char: '"' },
    { from: 'START', to: 'DELIMITER', label: ';', char: ';' },
    { from: 'START', to: 'KEYWORD', label: 'keyword', char: 'int|float|char|double' },
    { from: 'IDENTIFIER', to: 'IDENTIFIER', label: 'letter', char: '[a-zA-Z0-9_]' },
    { from: 'IDENTIFIER', to: 'OPERATOR', label: 'op', char: '[+\\-*/=]' },
    { from: 'IDENTIFIER', to: 'DELIMITER', label: ';', char: ';' },
    { from: 'NUMBER', to: 'NUMBER', label: 'digit', char: '[0-9.]' },
    { from: 'NUMBER', to: 'OPERATOR', label: 'op', char: '[+\\-*/]' },
    { from: 'NUMBER', to: 'DELIMITER', label: ';', char: ';' },
    { from: 'OPERATOR', to: 'IDENTIFIER', label: 'letter', char: '[a-zA-Z]' },
    { from: 'OPERATOR', to: 'NUMBER', label: 'digit', char: '[0-9]' },
    { from: 'STRING', to: 'STRING', label: 'char', char: '[^"]' },
    { from: 'STRING', to: 'IDENTIFIER', label: '"', char: '"' }
];

function switchDFAView(view) {
    const staticDFA = document.getElementById("staticDFA");
    
    // Hide all views first
    staticDFA.style.display = "none";
    
    if (view === 'static') {
        staticDFA.style.display = "block";
        drawStaticDFA();
    }
}

function drawStaticDFA() {
    const svg = d3.select("#dfaSvg");
    svg.selectAll("*").remove();
    
    const width = 800;
    const height = 400;
    
    // Simple clean DFA states
    const states = {
        'START': { x: 100, y: 200, color: '#28a745' },
        'IDENTIFIER': { x: 250, y: 100, color: '#17a2b8' },
        'NUMBER': { x: 400, y: 100, color: '#ffc107' },
        'OPERATOR': { x: 550, y: 100, color: '#dc3545' },
        'STRING': { x: 700, y: 100, color: '#6f42c1' },
        'DELIMITER': { x: 250, y: 300, color: '#e83e8c' },
        'KEYWORD': { x: 400, y: 300, color: '#6610f2' }
    };
    
    const transitions = [
        { from: 'START', to: 'IDENTIFIER', label: 'letter' },
        { from: 'START', to: 'NUMBER', label: 'digit' },
        { from: 'START', to: 'OPERATOR', label: 'op' },
        { from: 'START', to: 'STRING', label: '"' },
        { from: 'START', to: 'DELIMITER', label: ';' },
        { from: 'START', to: 'KEYWORD', label: 'keyword' },
        { from: 'IDENTIFIER', to: 'IDENTIFIER', label: 'letter/digit' },
        { from: 'NUMBER', to: 'NUMBER', label: 'digit/.' },
        { from: 'STRING', to: 'STRING', label: 'char' }
    ];
    
    // Draw states
    Object.keys(states).forEach(stateKey => {
        const state = states[stateKey];
        
        // State circle
        svg.append("circle")
            .attr("cx", state.x)
            .attr("cy", state.y)
            .attr("r", 30)
            .attr("fill", state.color)
            .attr("stroke", "#333")
            .attr("stroke-width", 2);
        
        // State label
        svg.append("text")
            .attr("x", state.x)
            .attr("y", state.y + 5)
            .attr("text-anchor", "middle")
            .style("font-weight", "bold")
            .style("fill", "white")
            .text(stateKey);
    });
    
    // Draw transitions
    transitions.forEach(transition => {
        const fromState = states[transition.from];
        const toState = states[transition.to];
        
        if (fromState && toState) {
            // Calculate arrow path
            const angle = Math.atan2(toState.y - fromState.y, toState.x - fromState.x);
            const endX = toState.x - 30 * Math.cos(angle);
            const endY = toState.y - 30 * Math.sin(angle);
            
            // Arrow line
            svg.append("line")
                .attr("x1", fromState.x + 30 * Math.cos(angle))
                .attr("y1", fromState.y + 30 * Math.sin(angle))
                .attr("x2", endX)
                .attr("y2", endY)
                .attr("stroke", "#666")
                .attr("stroke-width", 2)
                .attr("marker-end", "url(#arrowhead)");
            
            // Transition label
            const midX = (fromState.x + endX) / 2;
            const midY = (fromState.y + endY) / 2;
            
            svg.append("text")
                .attr("x", midX)
                .attr("y", midY - 5)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .style("fill", "#333")
                .text(transition.label);
        }
    });
    
    // Add arrow marker definition
    svg.append("defs")
        .append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 0 10 10")
        .attr("refX", 9)
        .attr("refY", 5)
        .attr("markerWidth", 8)
        .attr("markerHeight", 8)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M 0 0 L 10 5 L 0 10 z")
        .attr("fill", "#666");
}

</script>

</body>
</html>
